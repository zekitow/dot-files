require 'spec_helper'
require 'net/http'
require 'fakeweb'

describe ProductsController do
  
  describe "GET products with empty database " do
    context "empty products list" do
      before do
        Product.delete_all
        get :index
        @document = JSON.parse(response.body)
      end    
      it { response.should be_success }
      it { response.headers['Content-Type'].should == 'application/json; charset=utf-8' }
    end
  end

  describe "GET 'index'" do
    before :each do
      Product.delete_all
    end

    context "listing products with filters" do
      it "should fail to an invalid status" do
        2.times do create(:product); end
        get :index, :status => "invalid status"
        response.code.should == "422"
        JSON.parse(response.body)["error"].should == "invalid status"
      end
    end

    context "listing products by date" do
      it "should return nothing due to no products found in the period" do
        create(:product, :created_at => Time.parse('2012-02-26'));
        create(:product, :updated_at => Time.parse('2012-02-26'));
        create(:product, :deactivated_at => Time.parse('2012-02-26'));
        create(:product, :created_at => Time.parse('2012-02-26'), :updated_at=>Time.parse('2012-02-26'), :deactivated_at =>Time.parse('2012-02-26'));

        create(:product, :created_at =>Time.parse('2012-02-26'), :deactivated_at=>Time.parse('2012-02-26'));
        create(:product, :created_at =>Time.parse('2012-02-26'), :updated_at=>Time.parse('2012-02-26'));
        create(:product, :updated_at =>Time.parse('2012-02-26'), :deactivated_at=>Time.parse('2012-02-26'));

        get :list_by_date, :start_time => "2012-02-27", :end_time => "2012-02-27"
        assigns[:products].size.should == 0
      end

      it "should return three products using start_time parameter only" do
        create(:product, :created_at    =>Time.parse("2012-02-25"))
        create(:product, :updated_at    =>Time.parse("2012-02-26"))
        create(:product, :deactivated_at=>Time.parse("2012-02-27"))

        get :list_by_date, :start_time => "2012-02-25"
        assigns[:products].size.should == 3
      end
    
      it "should return three products usin end_time parameter only" do
        create(:product, :created_at    =>Time.parse("2012-02-24"))
        create(:product, :updated_at    =>Time.parse("2012-02-25"))
        create(:product, :deactivated_at=>Time.parse("2012-02-26"))

        get :list_by_date, :end_time => "2012-02-26"
        assigns[:products].size.should == 0
      end

      it "should return no products using end_time parameter only" do
        create(:product)
        create(:product, :created_at    =>Time.parse("2012-02-24"))
        create(:product, :updated_at    =>Time.parse("2012-02-25"))
        create(:product, :deactivated_at=>Time.parse("2012-02-26"))

        get :list_by_date, :end_time => "2012-02-26"
        assigns[:products].size.should == 0
      end

      it "should return three products using start_time and end_time parameters" do
        create(:product)
        create(:product, :created_at    =>Time.parse("2012-02-24"))
        create(:product, :updated_at    =>Time.parse("2012-02-25"))
        create(:product, :deactivated_at=>Time.parse("2012-02-26"))

        get :list_by_date, :start_time => "2012-02-24", :end_time => "2012-02-26"
        assigns[:products].size.should == 3
      end

      it "should return no products without start_time and end_time parameters" do
        create(:product, :created_at =>Time.parse("2012-02-25"))
        create(:product, :created_at =>Time.parse("2012-02-25"), :updated_at => Time.parse("2012-02-25"))
        create(:product, :created_at =>Time.parse("2012-02-25"), :deactivated_at => Time.parse("2012-02-25"))

        get :list_by_date
        assigns[:products].size.should == 0
      end

      it "should return product with start_time parameter and without end_time parameter" do
        create(:product, :created_at=>Time.parse("2012-02-25"))

        get :list_by_date, :start_time => "2012-02-25"
        assigns[:products].size.should == 1
      end

      it "should return no product with start_time parameter and without end_time parameter" do
        create(:product, :created_at=>Time.parse("2012-02-24"))

        get :list_by_date, :start_time => "2012-02-25"
        assigns[:products].size.should == 0
      end
 
      it "should return product without start_time parameter and with end_time parameter" do
        create(:product, :created_at=>Time.parse("2012-02-25"))

        get :list_by_date, :end_time => "20120225102030"
        assigns[:products].size.should == 0
      end

      it "should return no product without start_time parameter and with end_time parameter" do
        create(:product, :created_at=>Time.parse("20120225"))

        get :list_by_date, :end_time => "20120224"
        assigns[:products].size.should == 0
      end

      it "should return products from now if some date were invalid" do
        create(:product)
        get :list_by_date, :start_time => "20131801", :end_time => "20110201254050"
        response.code.should == "200"
      end
    end
  end

  describe "GET show" do
    context "showing a product" do
      it "gets the requested products as json" do
        product = create(:product)
        get :show, :id => product.id
        response.should be_success
        validate_fields(product, response).should be_true
      end
    end
  end

  describe "PUT update" do
    context "updating a product succesfully" do
      it "send a post request with the product information" do
        product = create(:product)
        post :update, :id => product.id, :product => can_edit_attributes
        validate_updated_product(product.id)
        response.code.should == "204"
        response.should be_success
      end
    end

    context "handling update errors" do
      it "cant update some attributes" do
        product = create(:product)
        post :update, :id => product.id, :product => cannot_edit_attributes
        response.code.should == "422"
        response.should_not be_success
      end

      it "should rescue from a product not found error" do
        wrong_id = "4f462a818dbe1d0e7f000005"
        post :update, :id => wrong_id, :product => {:description => "descricao2"}
        obj = ActiveSupport::JSON.decode(response.body)
        obj["message"].should eq("Document not found for class Product with id(s) #{wrong_id}.")
        obj["request"].should eq("/products/#{wrong_id}?product%5Bdescription%5D=descricao2")
        response.code.should == "404"
        response.should_not be_success
      end
      
      it "should rescue from a invalid format product id error" do
        wrong_id = "4f462a818dbe1d0e7f00000"
        post :update, :id => wrong_id, :product => {:description => "descricao2"}
        obj = ActiveSupport::JSON.decode(response.body)
        obj["message"].should eq("illegal ObjectId format: #{wrong_id}")
        obj["request"].should eq("/products/#{wrong_id}?product%5Bdescription%5D=descricao2")
        response.code.should == "400"
        response.should_not be_success
      end

      it "should rescue from a invalid document params product id error" do
        product = create(:product)
        legacy_id = "123"
        post :update, :id => product.id, :product => {:legacy_id => legacy_id}
        obj = ActiveSupport::JSON.decode(response.body)
        obj["message"].should eq("Invalid document parameters ({\"legacy_id\"=>\"#{legacy_id}\"}). ")
        obj["request"].should eq("/products/#{product.id}?product%5Blegacy_id%5D=#{legacy_id}")
        response.code.should == "422"
        response.should_not be_success
      end       
    end
  end

  describe "GET 'stats'" do
    it "should show the number of products" do
      expected_date = Time.parse('2012-03-15 19:06:00')
      expected_products = 98734
      Legacy::Produto.should_receive(:stats).with(expected_date).and_return({ date: expected_date, active: expected_products })
      get :stats, date: expected_date.strftime('%Y%m%d%H%M')
      response.code.should == "200"
      result = JSON.parse(response.body)
      result["date"].should == expected_date.iso8601
      result["active"].should == expected_products
    end
  end

private

  def validate_fields(product, response)
    obj = ActiveSupport::JSON.decode(response.body)
    obj["_id"].to_s               == (product._id).to_s &&
    obj["attrs"]["partner_order"] == (product.attrs[:partner_order]) &&
    obj["brand"]                  == (product.brand) &&
    obj["categories"]             == (product.categories) &&
    obj["colors"]                 == (product.colors) &&
    obj["created_at"].to_datetime == (product.created_at).to_datetime &&
    obj["deactivated_at"]         == (product.deactivated_at) &&
    obj["deleted_at"]             == (product.deleted_at) &&
    obj["edited_attrs"]["title"]  == (product.edited_attrs[:title]) &&
    obj["edited_attrs"]["color"]  == (product.edited_attrs[:color]) &&
    obj["images"]                 == (product.images) &&
    obj["legacy_id"]              == (product.legacy_id) &&
    obj["list_price"]             == (product.list_price) &&
    obj["partner_brand"]          == (product.partner_brand) &&
    obj["partner_categories"]     == (product.partner_categories) &&
    obj["partner_colors"]         == (product.partner_colors) &&
    obj["partner_description"]    == (product.partner_description) &&
    obj["partner_name"]           == (product.partner_name) &&
    obj["partner_sizes"]          == (product.partner_sizes) &&
    obj["partner_title"]          == (product.partner_title) &&
    obj["pct_savings"]            == (product.pct_savings) &&
    obj["product_url"]            == (product.product_url) &&
    obj["retail_price"]           == (product.retail_price) &&
    obj["savings"]                == (product.savings) &&
    obj["sizes"]                  == (product.sizes) &&
    obj["status"]                 == (product.status) &&
    obj["tags"]                   == (product.tags) &&
    obj["updated_at"].to_datetime == (product.updated_at).to_datetime
  end

  def can_edit_attributes
    {
     :title => "teste",
     :created_at => Time.now,
     :partner_name => "Sandalia / Teste",
     :partner_description => "produto Teste",
     :status => Product::STATUS_NEW,
     :sizes => ["34", "35"],
     :product_url => "http://localhost/sandalia-teste",
     :brand => "ellus",
     :updated_at => Time.now,
     :categories => ["teste", "teste2"],
     :partner_colors => ["amarelo"],
     :partner_categories => ["sapatos", "roupas"],
     :deactivated_at => nil,
     :attrs => {
       :partner_order => 9
     },
     :partner_brand => nil,
     :partner_sizes => nil
     }
  end

  def cannot_edit_attributes
    {
     :legacy_id => 123,
     :list_price => 1,
     :retail_price => 2
     }
  end

  def validate_updated_product(product_id)
    product = Product.find(product_id)
    a = can_edit_attributes

    product.title                 == a[:title]                 &&
    product.created_at.to_s       == a[:created_at].to_s       &&
    product.partner_name          == a[:partner_name]          &&
    product.partner_description   == a[:partner_description]   &&
    product.legacy_id             == a[:legacy_id]             &&
    product.status                == a[:status]                &&
    product.sizes                 == a[:sizes]                 &&
    product.product_url           == a[:product_url]           &&
    product.brand                 == a[:brand]                 &&
    product.updated_at            == a[:updated_at].to_s       &&
    product.cores_parceiro        == a[:cores_parceiro]        &&
    product.ordem_xml             == a[:ordem_xml]             &&
    product.categories            == a[:categories]            &&
    product.deactivated_at        == a[:deactivated_at]        &&
    product.partner_brand         == a[:partner_brand]         &&
    product.partner_sizes         == a[:partner_sizes]         &&
    product.attrs[:partner_order] == a[:attrs][:partner_order]

  end
end

