require 'capistrano/ext/multistage'
require 'bundler/capistrano'

$:.unshift(File.expand_path('./lib', ENV['rvm_path']))  # Add RVM's lib directory to the load path.
require "rvm/capistrano"                                # Load RVM's capistrano plugin.
set :rvm_ruby_string, ENV["rvm_ruby_string"]            # Or whatever env you want it to run in.

def get_branch_name
  puts ''
  puts '*********************************************************************'
  puts "Type the reference to the branch, tag, or any SHA1 you are deploying."
  branch_name = ENV['TAG']
  if branch_name.nil? || branch_name =~ /\A[\s\r\n]*\z/
    branch_name = Capistrano::CLI.ui.ask("Default: master")
    #branch_name = "master"
  else
    puts "TAG selected: #{ branch_name }"
  end
  branch_name = 'master' if branch_name == ''
  branch_name
end

def get_stages
  Dir['deploy/*.rb'].collect {|file| File.basename(file).gsub(File.extname(file),'')}
end

def yes_no(message)
  Capistrano::CLI.ui.ask(%(#{message} [Type "yes" or "no" (default: "no")])) === "yes"
end

def _text(message)
  Capistrano::CLI.ui.ask(message)
end

def _pass(message)
  Capistrano::CLI.password_prompt(message)
end

#set :bundle_cmd, '/usr/local/bin/bundle'

set :application,   "cap-products"
set :deploy_to,     "/abd/app/#{application}"
set :user,          "#{application}"
set :deploy_branch, ENV['BRANCH'] if ENV['BRANCH']
set :bundle_flags, "--quiet"
set :use_sudo,      false

# SCM Configurations
set :scm,              :git
set :repository,       "git@codebasehq.com:abril/seu-sapato/#{application}.git"
set :repository_cache, "git_#{application}"
set :deploy_via,       :remote_cache
set :shared_path,      "#{deploy_to}/shared/"
set :logs_path,        "/abd/logs/#{application}"

default_run_options[:pty] = true

set :stages, get_stages

before "deploy", "deploy:set_branch_name", "deploy:setup_directories"
before "deploy:migrations", "deploy:set_branch_name"
after "deploy:update_code", "deploy:copy_config_files"
after "deploy:finalize_update", "deploy:relink_log"
#before "deploy:symlink", "deploy:check_environment_before_synlink"
after "deploy","deploy:restart_redis", "deploy:cleanup","deploy:restart_workers" 

namespace :deploy do
  desc "[internal] Relink log"
  task :relink_log do
     run <<-CMD
        mkdir #{logs_path};
        rm #{latest_release}/log &&
        ln -s #{logs_path} #{latest_release}/log
     CMD
  end

  desc "[internal] Check environment before symlink"
  task :check_environment_before_synlink, :except => { :no_release => true } do
    on_rollback { run "rm -rf #{current_release}; true" }
    run <<-CMD
      cd #{current_release};
      ./script/rails runner "puts Rails.env"
    CMD
  end

  desc "Restarting Resque workers"
  task :restart_workers do
    # run "cd #{current_release} && bundle exec rake resque:work QUEUE=\"*\" &", :pty => true
    puts "REINICIAR MANUALMENTE A FILA (resque:work QUEUE=\"*\" &) EM #{current_release}."
  end
  
  desc "Restarting Redis Server"
  task :restart_redis, :roles => :redis do
     run "sudo /etc/init.d/redis restart", :pty => true
  end

  desc "[internal] Set a branch/tag or SHA1"
  task :set_branch_name do
    set :branch, get_branch_name
  end

  desc "[internal] Create config dir on shared_path"
  task :setup_directories  do
    run "if [[ ! -d #{shared_path}/config ]]; then mkdir -p #{shared_path}/config; fi"
    run "if [[ ! -d #{deploy_to}/releases ]]; then mkdir -p #{deploy_to}/releases; fi"
  end

  desc "[internal] Copy config files to current_release"
  task :copy_config_files do
    run <<-CMD
      ls #{shared_path}/config/*.yml > /dev/null 2>&1;
      if [[ $? == 0 ]]; then
        cp #{shared_path}/config/*.yml #{current_release}/config/;
      else
        cp #{current_release}/config/*.yml #{shared_path}/config/;
      fi;
    CMD
    run <<-CMD
      if [[ -f #{shared_path}/config/#{rails_env}.rb ]]; then
        cp #{shared_path}/config/#{rails_env}.rb #{current_release}/config/environments/;
      fi
    CMD
  end

  desc "Restarting passenger"
  task :restart, :roles => :app, :except => {:no_release => true } do
    run <<-CMD
      mkdir -p #{current_path}/tmp &&
      touch #{current_path}/tmp/restart.txt
    CMD
  end

  [:stop, :start].each do |t|
    desc "[internal] #{t} server"
    task t, :role => :app, :except => {:no_release => true } do
      puts "Do nothing for #{t} cap task."
    end
  end
end
