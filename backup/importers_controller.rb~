require 'will_paginate/array'
require 'iconv'
require 'net/http'
require 'ruby-debug'
class ImportersController < ApplicationController

  before_filter :find_partner, :only => [:create, :index]
  before_filter :find_importer, :only => [:show, :update]

  # Lista logs de importacao.
  #  $ curl -i -X GET http://localhost:3000/importers\?limit\=10\&page\=2
  #
  # @param :limit
  # @param :start_time
  # @param :end_time
  # @param :partner_slug
  # @param :page
  # @return [Array] De importers
  def index
    limit = (params[:limit] && params[:limit].to_i) || Settings.api.default_result_limit
    start_time = parse_start_time(params[:start_time])
    end_time   = parse_end_time(params[:end_time])
    if params[:partner_slug]
      @importers = Importer.all(:conditions => {:partner_id => @partner.id}).find_by_period(start_time, end_time).paginate(:page => params[:page], :per_page => limit)
    else
      @importers = Importer.find_by_period(start_time, end_time).paginate(:page => params[:page], :per_page => limit)
    end
  end

  # Cria uma importacao de produtos
  #  $ curl -i -X POST http://localhost:3000/importers -d 'partner_slug=anita'
  #
  # @param :partner_slug
  # @return :conflict    se o parceiro ja estiver sendo importado
  # @return :created     se criar a importacao
  # @return :bad_gateway se o java nao lancar Exception
  # @return :not_found   se nao houver parceiro com o :partner_slug
  # @return :internal_server_error se nao conseguir criar importacao
  def create
    if importation_already_running? @partner
      render :json => { :message => "Import with partner #{params[:partner_slug]} already running", :request => request.fullpath }, :status => :conflict
    else
      @importer = Importer.new :partner_id => @partner.id
      if @importer.save
        status_code = call_importer(@partner.legacy_id, @importer.id)
        if status_code == "200"
          @importer.status = Importer::STATUS_IMPORTING
          @importer.save!
          head :created, :location => importer_path(@importer)
        else
          @importer.status = Importer::STATUS_ERROR
          @importer.save!
          render :json => @importer, :status => status_code
        end
      else
        invalid_document_params(params)
      end
    end
  end

  # Exibe logs de importacao
  #  $ curl -i -X GET http://localhost:3000/importers/4f67423065bde163b7000005
  #
  # @param  ObjectId do Importer
  # @return [Array] De Importer
  # @return :not_found se nao encontrar o Hash
  def show
    render :json => @importer, :status => :ok
  end

  # Recebe o callback do importador java.
  #  $ curl -i -X PUT http://localhost:3000/importers/4f67423065bde163b7000005 -d 'import_metrics={ ... }'
  #
  # @param  :import_metrics (json contendo callback)
  # @return :nothing
  # @return :internal_server_error
  def update
    begin
      ic = Iconv.new('UTF-8', 'ISO-8859-1')
      json = CGI::unescape(ic.iconv(params[:import_metrics]))
      importer_admin = JSON.parse(json)
      logger.info("Import status #{importer_admin['import_status']}.")
      @importer.parse(importer_admin)
      unless importer_admin['import_status'] == "ERROR"
        start_time = DateTime.strptime(importer_admin['start_time'], "%Y-%m-%d %H:%M:%S.%L")
        end_time = DateTime.strptime(importer_admin['end_time'], "%Y-%m-%d %H:%M:%S.%L")
        logger.info("Adding #{importer_admin['partner_name']} to queue.")
        @importer.status = Importer::STATUS_EXECUTING
        @importer.save!
        Resque.enqueue(ImportProductsWorker, @importer.id, start_time, end_time)
      else
        @importer.status = Importer::STATUS_ERROR
        @importer.save!
      end
      render :nothing => true
    rescue Exception => ex
      @importer.status = Importer::STATUS_ERROR
      @importer.error_details = ex
      logger.error("Could not import products: #{ex}")
      head :internal_server_error
    end
  end

  private
  def find_partner
    @partner = Partner.find_by_slug(params[:partner_slug]) if params[:partner_slug]
    if params[:partner_slug] and @partner.nil?
      render :json => { :message => "Partner not found.",  :request => request.fullpath }, :status => :not_found
    end
  end

  def find_importer
    @importer = Importer.find(params[:id])
  end

  def call_importer(partner_legacy_id, importer_id)
    begin
      uri = URI.parse(URI.encode("#{Settings.importer.url}#{partner_legacy_id}"));
      content = Net::HTTP.post_form(uri, "callback" => "#{Settings.importer.callback}/importers/#{importer_id}")
    rescue Exception => ex
      logger.error("Could not connect to #{uri}: #{ex}.")
      return :bad_gateway
    end
    content.code
  end

  def importation_already_running?(partner)
    importer = Importer.last_execution(partner.id)
    [Importer::STATUS_RECEIVED, Importer::STATUS_EXECUTING, Importer::STATUS_IMPORTING].include? importer.status unless importer.nil?
  end

end

