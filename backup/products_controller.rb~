require 'net/http'
require 'date'
require 'will_paginate/array'
require 'iconv'

class ProductsController < ApplicationController

  protect_from_forgery :only => []
  before_filter :find_product, :only => [:show, :update]

  def index
    limit = params[:limit].nil?   ? Settings.api.default_result_limit : params[:limit].to_i
    status = params[:status].nil? ? Product::STATUS_ACTIVE : params[:status]
    categories = params[:categories].nil? ? [] : params[:categories].split(",")

    unless Product.has_status? status
      render :json => {"error" => "invalid status"}, :status => :unprocessable_entity
    else
      products = Product.all(:conditions => {:status => status})
      products = products.any_in(:categories => categories) if categories.length > 0
      @products = products.paginate(:page => params[:page], :per_page => limit)
    end
  end

  def show
    start_time = parse_start_time(params['start_time'])
    end_time   = parse_end_time(params['end_time'])
#    if stale?(:last_modified => @product.updated_at, :etag => @product)
      render :json => @product
#    end
  end

  def update
    unless can_update?(params[:product])
      invalid_document_params(params[:product])
    else
      head :no_content if @product.update_attributes(params[:product])
    end
  end

  def list_by_date
    @start_time = parse_start_time(params['start_time'])
    @end_time   = parse_end_time(params['end_time'])
    @products = Product.find_by_created_updated_or_deactivated(params, @start_time, @end_time)
    render :index
    # products = add_footer_info_to_json_paginate(products, start_time, end_time)
    # render :json => products, :status => :ok
  end
  
  def stats
    date = params[:date].nil? ? Time.now : Time.parse(params[:date])
    render :json => Legacy::Produto.stats(date), :status => :ok
  end

private
  def find_product
    @product = Product.find(params[:id])
  end

  def can_update?(params)
    !Product::PROTECTED_FIELDS.collect{|c| params.include?(c)}.include?(true)
  end

end

